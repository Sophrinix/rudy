module ruby.c.intern;

private import ruby.c.common;
private import ruby.c.ruby;
private import ruby.c.node;
private import ruby.c.st;
private import std.c.linux.linux;


extern (C) {

void rb_mem_clear (VALUE*, int);
VALUE rb_assoc_new (VALUE, VALUE);
VALUE rb_check_array_type (VALUE);
VALUE rb_ary_new ();
VALUE rb_ary_new2 (int);
VALUE rb_ary_new3 (int,...);
VALUE rb_ary_new4 (int,  VALUE *);
VALUE rb_ary_freeze (VALUE);
VALUE rb_ary_aref (int, VALUE*, VALUE);
void rb_ary_store (VALUE, int, VALUE);
VALUE rb_ary_dup (VALUE);
VALUE rb_ary_to_ary (VALUE);
VALUE rb_ary_to_s (VALUE);
VALUE rb_ary_push (VALUE, VALUE);
VALUE rb_ary_pop (VALUE);
VALUE rb_ary_shift (VALUE);
VALUE rb_ary_unshift (VALUE, VALUE);
VALUE rb_ary_entry (VALUE, int);
VALUE rb_ary_each (VALUE);
VALUE rb_ary_join (VALUE, VALUE);
VALUE rb_ary_print_on (VALUE, VALUE);
VALUE rb_ary_reverse (VALUE);
VALUE rb_ary_sort (VALUE);
VALUE rb_ary_sort_bang (VALUE);
VALUE rb_ary_delete (VALUE, VALUE);
VALUE rb_ary_delete_at (VALUE, int);
VALUE rb_ary_clear (VALUE);
VALUE rb_ary_plus (VALUE, VALUE);
VALUE rb_ary_concat (VALUE, VALUE);
VALUE rb_ary_assoc (VALUE, VALUE);
VALUE rb_ary_rassoc (VALUE, VALUE);
VALUE rb_ary_includes (VALUE, VALUE);
VALUE rb_ary_cmp (VALUE, VALUE);
VALUE rb_protect_inspect (VALUE(*)(/* ANYARGS */),VALUE,VALUE);
VALUE rb_inspecting_p (VALUE);
VALUE rb_check_array_value (VALUE);
VALUE rb_values_at (VALUE, int, int, VALUE*, VALUE(*) (VALUE,int));

VALUE rb_big_clone (VALUE);
void rb_big_2comp (VALUE);
VALUE rb_big_norm (VALUE);
VALUE rb_uint2big (uint);
VALUE rb_int2big (int);
VALUE rb_uint2inum (uint);
VALUE rb_int2inum (int);
VALUE rb_cstr_to_inum ( char*, int, int);
VALUE rb_str_to_inum (VALUE, int, int);
VALUE rb_cstr2inum ( char*, int);
VALUE rb_str2inum (VALUE, int);
VALUE rb_big2str (VALUE, int);
int rb_big2long (VALUE);
uint rb_big2ulong (VALUE);

void rb_quad_pack (char*,VALUE);
VALUE rb_quad_unpack ( char*,int);
VALUE rb_dbl2big (double);
double rb_big2dbl (VALUE);
VALUE rb_big_plus (VALUE, VALUE);
VALUE rb_big_minus (VALUE, VALUE);
VALUE rb_big_mul (VALUE, VALUE);
VALUE rb_big_divmod (VALUE, VALUE);
VALUE rb_big_pow (VALUE, VALUE);
VALUE rb_big_and (VALUE, VALUE);
VALUE rb_big_or (VALUE, VALUE);
VALUE rb_big_xor (VALUE, VALUE);
VALUE rb_big_lshift (VALUE, VALUE);
VALUE rb_big_rand (VALUE, double*);

VALUE rb_class_boot (VALUE);
VALUE rb_class_new (VALUE);
VALUE rb_mod_init_copy (VALUE, VALUE);
VALUE rb_class_init_copy (VALUE, VALUE);
VALUE rb_singleton_class_clone (VALUE);
void rb_singleton_class_attached (VALUE,VALUE);
VALUE rb_make_metaclass (VALUE, VALUE);
void rb_check_inheritable (VALUE);
VALUE rb_class_inherited (VALUE, VALUE);
VALUE rb_define_class_id (ID, VALUE);
VALUE rb_module_new ();
VALUE rb_define_module_id (ID);
VALUE rb_mod_included_modules (VALUE);
VALUE rb_mod_include_p (VALUE, VALUE);
VALUE rb_mod_ancestors (VALUE);
VALUE rb_class_instance_methods (int, VALUE*, VALUE);
VALUE rb_class_public_instance_methods (int, VALUE*, VALUE);
VALUE rb_class_protected_instance_methods (int, VALUE*, VALUE);
VALUE rb_class_private_instance_methods (int, VALUE*, VALUE);
VALUE rb_obj_singleton_methods (int, VALUE*, VALUE);
void rb_define_method_id (VALUE, ID, VALUE (*)(/* ANYARGS */), int);
void rb_frozen_class_p (VALUE);
void rb_undef (VALUE, ID);
void rb_define_protected_method (VALUE,  char*, VALUE (*)(/* ANYARGS */), int);
void rb_define_private_method (VALUE,  char*, VALUE (*)(/* ANYARGS */), int);
void rb_define_singleton_method (VALUE,  char*, VALUE(*)(/* ANYARGS */), int);
VALUE rb_singleton_class (VALUE);

int rb_cmpint (VALUE, VALUE, VALUE);
void rb_cmperr (VALUE, VALUE);

extern int ruby_nerrs;
VALUE rb_exc_new (VALUE,  char*, int);
VALUE rb_exc_new2 (VALUE,  char*);
VALUE rb_exc_new3 (VALUE, VALUE);
void rb_loaderror (char*, ...);
void rb_name_error (ID,  char*, ...);
void rb_invalid_str (char*, char*);
void rb_compile_error ( char*, ...);
void rb_compile_error_append ( char*, ...);
void rb_load_fail ( char*);
void rb_error_frozen ( char*);
void rb_check_frozen (VALUE);

extern RNode *ruby_current_node;
void ruby_set_current_source ();
void rb_exc_raise (VALUE);
void rb_exc_fatal (VALUE);
VALUE rb_f_exit (int,VALUE*);
VALUE rb_f_abort (int,VALUE*);
void rb_remove_method (VALUE,  char*);

void rb_define_alloc_func (VALUE, VALUE (*)(VALUE));
void rb_undef_alloc_func (VALUE);
void rb_clear_cache ();
void rb_clear_cache_by_class (VALUE);
void rb_alias (VALUE, ID, ID);
void rb_attr (VALUE,ID,int,int,int);
int rb_method_boundp (VALUE, ID, int);
VALUE rb_dvar_defined (ID);
VALUE rb_dvar_curr (ID);
VALUE rb_dvar_ref (ID);
void rb_dvar_asgn (ID, VALUE);
void rb_dvar_push (ID, VALUE);
VALUE *rb_svar (int);
VALUE rb_eval_cmd (VALUE, VALUE, int);
int rb_obj_respond_to (VALUE, ID, int);
int rb_respond_to (VALUE, ID);
void rb_interrupt ();
VALUE rb_apply (VALUE, ID, VALUE);
void rb_backtrace ();
ID rb_frame_last_func ();
VALUE rb_obj_instance_eval (int, VALUE*, VALUE);
VALUE rb_mod_module_eval (int, VALUE*, VALUE);
void rb_load (VALUE, int);
void rb_load_protect (VALUE, int, int*);
void rb_jump_tag (int);
int rb_provided ( char*);
void rb_provide ( char*);
VALUE rb_f_require (VALUE, VALUE);
VALUE rb_require_safe (VALUE, int);
void rb_obj_call_init (VALUE, int, VALUE*);
VALUE rb_class_new_instance (int, VALUE*, VALUE);
VALUE rb_block_proc ();
VALUE rb_f_lambda ();
VALUE rb_proc_new (VALUE (*)(/* ANYARGS */ ), VALUE);
VALUE rb_protect (VALUE (*)(VALUE), VALUE, int*);
void rb_set_end_proc (void (*)(VALUE), VALUE);
void rb_mark_end_proc ();
void rb_exec_end_proc ();
void ruby_finalize ();
void ruby_stop (int);
int ruby_cleanup (int);
int ruby_exec ();
void rb_gc_mark_threads ();
void rb_thread_start_timer ();
void rb_thread_stop_timer ();
void rb_thread_schedule ();
void rb_thread_wait_fd (int);
int rb_thread_fd_writable (int);
void rb_thread_fd_close (int);
int rb_thread_alone ();
void rb_thread_polling ();
void rb_thread_sleep (int);
void rb_thread_sleep_forever ();
VALUE rb_thread_stop ();
VALUE rb_thread_wakeup (VALUE);
VALUE rb_thread_run (VALUE);
VALUE rb_thread_kill (VALUE);
VALUE rb_thread_create (VALUE (*)(/* ANYARGS */), void*);
void rb_thread_interrupt ();
void rb_thread_trap_eval (VALUE, int, int);
void rb_thread_signal_raise (char*);
void rb_thread_signal_exit ();
int rb_thread_select (int, fd_set *, fd_set *, fd_set *, timeval *);
void rb_thread_wait_for (timeval);
VALUE rb_thread_current ();
VALUE rb_thread_main ();
VALUE rb_thread_local_aref (VALUE, ID);
VALUE rb_thread_local_aset (VALUE, ID, VALUE);
void rb_thread_atfork ();
VALUE rb_funcall_rescue (VALUE, ID, int, ...);

int eaccess ( char*, int);
VALUE rb_file_s_expand_path (int, VALUE *);
VALUE rb_file_expand_path (VALUE, VALUE);
void rb_file_const ( char*, VALUE);
int rb_find_file_ext (VALUE*,  char* *);
VALUE rb_find_file (VALUE);
char *rb_path_next ( char *);
char *rb_path_skip_prefix ( char *);
char *rb_path_last_separator ( char *);
char *rb_path_end ( char *);

void rb_memerror ();
int ruby_stack_check ();
int ruby_stack_length (VALUE**);
char *rb_source_filename ( char*);
void rb_gc_mark_locations (VALUE*, VALUE*);
void rb_mark_tbl (st_table*);
void rb_mark_hash (st_table*);
void rb_gc_mark_maybe (VALUE);
void rb_gc_mark (VALUE);
void rb_gc_force_recycle (VALUE);
void rb_gc ();
void rb_gc_copy_finalizer (VALUE,VALUE);
void rb_gc_finalize_deferred ();
void rb_gc_call_finalizer_at_exit ();
VALUE rb_gc_enable ();
VALUE rb_gc_disable ();
VALUE rb_gc_start ();

void st_foreach_safe (st_table *, int (*)(/* ANYARGS */), uint);
void rb_hash_foreach (VALUE, int (*)(/* ANYARGS */), VALUE);
VALUE rb_hash (VALUE);
VALUE rb_hash_new ();
VALUE rb_hash_freeze (VALUE);
VALUE rb_hash_aref (VALUE, VALUE);
VALUE rb_hash_aset (VALUE, VALUE, VALUE);
VALUE rb_hash_delete_if (VALUE);
VALUE rb_hash_delete (VALUE,VALUE);
int rb_path_check (char*);
int rb_env_path_tainted ();


extern VALUE rb_fs;
extern VALUE rb_output_fs;
extern VALUE rb_rs;
extern VALUE rb_default_rs;
extern VALUE rb_output_rs;
VALUE rb_io_write (VALUE, VALUE);
VALUE rb_io_gets (VALUE);
VALUE rb_io_getc (VALUE);
VALUE rb_io_ungetc (VALUE, VALUE);
VALUE rb_io_close (VALUE);
VALUE rb_io_eof (VALUE);
VALUE rb_io_binmode (VALUE);
VALUE rb_io_addstr (VALUE, VALUE);
VALUE rb_io_printf (int, VALUE*, VALUE);
VALUE rb_io_print (int, VALUE*, VALUE);
VALUE rb_io_puts (int, VALUE*, VALUE);
VALUE rb_file_open ( char*,  char*);
VALUE rb_gets ();
void rb_write_error ( char*);
void rb_write_error2 ( char*, int);

VALUE rb_marshal_dump (VALUE, VALUE);
VALUE rb_marshal_load (VALUE);

void rb_num_zerodiv ();
VALUE rb_num_coerce_bin (VALUE, VALUE);
VALUE rb_num_coerce_cmp (VALUE, VALUE);
VALUE rb_num_coerce_relop (VALUE, VALUE);
VALUE rb_float_new (double);
VALUE rb_num2fix (VALUE);
VALUE rb_fix2str (VALUE, int);
VALUE rb_dbl_cmp (double, double);

int rb_eql (VALUE, VALUE);
VALUE rb_any_to_s (VALUE);
VALUE rb_inspect (VALUE);
VALUE rb_obj_is_instance_of (VALUE, VALUE);
VALUE rb_obj_is_kind_of (VALUE, VALUE);
VALUE rb_obj_alloc (VALUE);
VALUE rb_obj_clone (VALUE);
VALUE rb_obj_dup (VALUE);
VALUE rb_obj_init_copy (VALUE,VALUE);
VALUE rb_obj_taint (VALUE);
VALUE rb_obj_tainted (VALUE);
VALUE rb_obj_untaint (VALUE);
VALUE rb_obj_freeze (VALUE);
VALUE rb_obj_id (VALUE);
VALUE rb_obj_class (VALUE);
VALUE rb_class_real (VALUE);
VALUE rb_class_inherited_p (VALUE, VALUE);
VALUE rb_convert_type (VALUE,int, char*, char*);
VALUE rb_check_convert_type (VALUE,int, char*, char*);
VALUE rb_to_int (VALUE);
VALUE rb_Integer (VALUE);
VALUE rb_Float (VALUE);
VALUE rb_String (VALUE);
VALUE rb_Array (VALUE);
double rb_cstr_to_dbl ( char*, int);
double rb_str_to_dbl (VALUE, int);

extern int ruby_sourceline;
extern char *ruby_sourcefile;
int ruby_yyparse ();
ID rb_id_attrset (ID);
void rb_parser_append_print ();
void rb_parser_while_loop (int, int);
int ruby_parser_stack_on_heap ();
void rb_gc_mark_parser ();
int rb_is_const_id (ID);
int rb_is_instance_id (ID);
int rb_is_class_id (ID);
int rb_is_local_id (ID);
int rb_is_junk_id (ID);
int rb_symname_p ( char*);
VALUE rb_backref_get ();
void rb_backref_set (VALUE);
VALUE rb_lastline_get ();
void rb_lastline_set (VALUE);
VALUE rb_sym_all_symbols ();

int rb_proc_exec ( char*);
VALUE rb_f_exec (int,VALUE*);
int rb_waitpid (int,int*,int);
void rb_syswait (int);
VALUE rb_proc_times (VALUE);
VALUE rb_detach_process (int);

VALUE rb_range_new (VALUE, VALUE, int);
VALUE rb_range_beg_len (VALUE, int*, int*, int, int);
VALUE rb_length_by_each (VALUE);

int rb_memcmp (char*,char*,int);
int rb_memcicmp (char*,char*,int);
int rb_memsearch (char*,int,char*,int);
VALUE rb_reg_nth_defined (int, VALUE);
VALUE rb_reg_nth_match (int, VALUE);
VALUE rb_reg_last_match (VALUE);
VALUE rb_reg_match_pre (VALUE);
VALUE rb_reg_match_post (VALUE);
VALUE rb_reg_match_last (VALUE);
VALUE rb_reg_new ( char*, int, int);
VALUE rb_reg_match (VALUE, VALUE);
VALUE rb_reg_match2 (VALUE);
int rb_reg_options (VALUE);
void rb_set_kcode ( char*);
char* rb_get_kcode ();

extern VALUE rb_argv;
extern VALUE rb_argv0;
void rb_load_file ( char*);
void ruby_script ( char*);
void ruby_prog_init ();
void ruby_set_argv (int, char**);
void ruby_process_options (int, char**);
void ruby_load_script ();
void ruby_init_loadpath ();
void ruby_incpush ( char*);

VALUE rb_f_kill (int, VALUE*);
void rb_gc_mark_trap_list ();

void rb_trap_exit ();
void rb_trap_exec ();
char *ruby_signal_name (int);

VALUE rb_f_sprintf (int, VALUE*);

VALUE rb_str_new ( char*, int);
VALUE rb_str_new2 ( char*);
VALUE rb_str_new3 (VALUE);
VALUE rb_str_new4 (VALUE);
VALUE rb_str_new5 (VALUE,  char*, int);
VALUE rb_tainted_str_new ( char*, int);
VALUE rb_tainted_str_new2 ( char*);
VALUE rb_str_buf_new (int);
VALUE rb_str_buf_new2 ( char*);
VALUE rb_str_buf_append (VALUE, VALUE);
VALUE rb_str_buf_cat (VALUE,  char*, int);
VALUE rb_str_buf_cat2 (VALUE,  char*);
VALUE rb_obj_as_string (VALUE);
VALUE rb_check_string_type (VALUE);
VALUE rb_str_dup (VALUE);
VALUE rb_str_locktmp (VALUE);
VALUE rb_str_unlocktmp (VALUE);
VALUE rb_str_dup_frozen (VALUE);
VALUE rb_str_plus (VALUE, VALUE);
VALUE rb_str_times (VALUE, VALUE);
VALUE rb_str_substr (VALUE, int, int);
void rb_str_modify (VALUE);
VALUE rb_str_freeze (VALUE);
VALUE rb_str_resize (VALUE, int);
VALUE rb_str_cat (VALUE,  char*, int);
VALUE rb_str_cat2 (VALUE,  char*);
VALUE rb_str_append (VALUE, VALUE);
VALUE rb_str_concat (VALUE, VALUE);
int rb_str_hash (VALUE);
int rb_str_cmp (VALUE, VALUE);
VALUE rb_str_upto (VALUE, VALUE, int);
void rb_str_update (VALUE, int, int, VALUE);
VALUE rb_str_inspect (VALUE);
VALUE rb_str_dump (VALUE);
VALUE rb_str_split (VALUE,  char*);
void rb_str_associate (VALUE, VALUE);
VALUE rb_str_associated (VALUE);
void rb_str_setter (VALUE, ID, VALUE*);
VALUE rb_str_intern (VALUE);

VALUE rb_struct_new (VALUE, ...);
VALUE rb_struct_define ( char*, ...);
VALUE rb_struct_alloc (VALUE, VALUE);
VALUE rb_struct_aref (VALUE, VALUE);
VALUE rb_struct_aset (VALUE, VALUE, VALUE);
VALUE rb_struct_getmember (VALUE, ID);
VALUE rb_struct_iv_get (VALUE, char*);
VALUE rb_struct_s_members (VALUE);
VALUE rb_struct_members (VALUE);

VALUE rb_time_new (time_t, time_t);

VALUE rb_mod_name (VALUE);
VALUE rb_class_path (VALUE);
void rb_set_class_path (VALUE, VALUE,  char*);
VALUE rb_path2class ( char*);
void rb_name_class (VALUE, ID);
VALUE rb_class_name (VALUE);
void rb_autoload (VALUE, ID,  char*);
VALUE rb_autoload_load (VALUE, ID);
VALUE rb_autoload_p (VALUE, ID);
void rb_gc_mark_global_tbl ();
VALUE rb_f_trace_var (int, VALUE*);
VALUE rb_f_untrace_var (int, VALUE*);
VALUE rb_f_global_variables ();
void rb_alias_variable (ID, ID);
st_table* rb_generic_ivar_table (VALUE);
void rb_copy_generic_ivar (VALUE,VALUE);
void rb_mark_generic_ivar (VALUE);
void rb_mark_generic_ivar_tbl ();
void rb_free_generic_ivar (VALUE);
VALUE rb_ivar_get (VALUE, ID);
VALUE rb_ivar_set (VALUE, ID, VALUE);
VALUE rb_ivar_defined (VALUE, ID);
VALUE rb_iv_set (VALUE,  char*, VALUE);
VALUE rb_iv_get (VALUE,  char*);
VALUE rb_attr_get (VALUE, ID);
VALUE rb_obj_instance_variables (VALUE);
VALUE rb_obj_remove_instance_variable (VALUE, VALUE);
void *rb_mod_const_at (VALUE, void*);
void *rb_mod_const_of (VALUE, void*);
VALUE rb_const_list (void*);
VALUE rb_mod_constants (VALUE);
VALUE rb_mod_remove_const (VALUE, VALUE);
int rb_const_defined (VALUE, ID);
int rb_const_defined_at (VALUE, ID);
int rb_const_defined_from (VALUE, ID);
VALUE rb_const_get (VALUE, ID);
VALUE rb_const_get_at (VALUE, ID);
VALUE rb_const_get_from (VALUE, ID);
void rb_const_set (VALUE, ID, VALUE);
VALUE rb_mod_constants (VALUE);
VALUE rb_mod_const_missing (VALUE,VALUE);
VALUE rb_cvar_defined (VALUE, ID);

void rb_cvar_set (VALUE, ID, VALUE, int);
VALUE rb_cvar_get (VALUE, ID);
void rb_cv_set (VALUE,  char*, VALUE);
VALUE rb_cv_get (VALUE,  char*);
void rb_define_class_variable (VALUE,  char*, VALUE);
VALUE rb_mod_class_variables (VALUE);
VALUE rb_mod_remove_cvar (VALUE, VALUE);

void ruby_show_version ();
void ruby_show_copyright ();
}

